<<<<<<< HEAD
# RUN: llc -mtriple=amdgcn-amd-amdhsa -amdgpu-dce-in-ra=0 -verify-machineinstrs -stress-regalloc=1 -start-before=simple-register-coalescing -stop-after=greedy -o - %s | FileCheck %s
# https://bugs.llvm.org/show_bug.cgi?id=33620

---
# This would assert due to the empty live interval created for %9
=======
# RUN: llc -mtriple=amdgcn-amd-amdhsa-opencl -verify-machineinstrs -stress-regalloc=1 -start-before=simple-register-coalescing -stop-after=greedy -o - %s | FileCheck %s
# https://bugs.llvm.org/show_bug.cgi?id=33620

---
# This would assert due to the empty live interval created for %vreg9
>>>>>>> origin/release/5.x
# on the last S_NOP with an undef subreg use.

# CHECK-LABEL: name: expecting_non_empty_interval

<<<<<<< HEAD
# CHECK: undef %7.sub1:vreg_64 = V_MAC_F32_e32 0, undef %1:vgpr_32, undef %7.sub1, implicit $exec
# CHECK-NEXT: SI_SPILL_V64_SAVE %7, %stack.0, $sgpr0_sgpr1_sgpr2_sgpr3, $sgpr32, 0, implicit $exec :: (store 8 into %stack.0, align 4, addrspace 5)
# CHECK-NEXT: undef %5.sub1:vreg_64 = V_MOV_B32_e32 1786773504, implicit $exec
# CHECK-NEXT: dead %3:vgpr_32 = V_MUL_F32_e32 0, %5.sub1, implicit $exec

# CHECK: S_NOP 0, implicit %6.sub1
# CHECK-NEXT: %8:vreg_64 = SI_SPILL_V64_RESTORE %stack.0, $sgpr0_sgpr1_sgpr2_sgpr3, $sgpr32, 0, implicit $exec :: (load 8 from %stack.0, align 4, addrspace 5)
=======
# CHECK: undef %7.sub1 = V_MAC_F32_e32 0, undef %1, undef %7.sub1, implicit %exec
# CHECK-NEXT: SI_SPILL_V64_SAVE %7, %stack.0, %sgpr0_sgpr1_sgpr2_sgpr3, %sgpr5, 0, implicit %exec :: (store 8 into %stack.0, align 4)
# CHECK-NEXT: undef %5.sub1 = V_MOV_B32_e32 1786773504, implicit %exec
# CHECK-NEXT: dead %2 = V_MUL_F32_e32 0, %5.sub1, implicit %exec

# CHECK: S_NOP 0, implicit %6.sub1
# CHECK-NEXT: %8 = SI_SPILL_V64_RESTORE %stack.0, %sgpr0_sgpr1_sgpr2_sgpr3, %sgpr5, 0, implicit %exec :: (load 8 from %stack.0, align 4)
>>>>>>> origin/release/5.x
# CHECK-NEXT: S_NOP 0, implicit %8.sub1
# CHECK-NEXT: S_NOP 0, implicit undef %9.sub0

name: expecting_non_empty_interval
tracksRegLiveness: true
<<<<<<< HEAD
machineFunctionInfo:
  scratchRSrcReg: $sgpr0_sgpr1_sgpr2_sgpr3
  scratchWaveOffsetReg: $sgpr4
  stackPtrOffsetReg: $sgpr32
body:             |
  bb.0:
    successors: %bb.1

    undef %0.sub1:vreg_64 = V_MAC_F32_e32 0, undef %1:vgpr_32, undef %0.sub1, implicit $exec
    undef %2.sub1:vreg_64 = V_MOV_B32_e32 1786773504, implicit $exec
    dead %3:vgpr_32 = V_MUL_F32_e32 0, %2.sub1, implicit $exec

  bb.1:
    S_NOP 0, implicit %2.sub1
    S_NOP 0, implicit %0.sub1
    S_NOP 0, implicit undef %0.sub0
=======
registers:
  - { id: 0, class: vreg_64, preferred-register: '' }
  - { id: 1, class: vgpr_32, preferred-register: '' }
  - { id: 2, class: vgpr_32, preferred-register: '' }
  - { id: 3, class: vreg_64, preferred-register: '' }
body:             |
  bb.0:
    successors: %bb.1
    undef %0.sub1 = V_MAC_F32_e32 0, undef %1, undef %0.sub1, implicit %exec
    undef %3.sub1 = V_MOV_B32_e32 1786773504, implicit %exec
    dead %2 = V_MUL_F32_e32 0, %3.sub1, implicit %exec

  bb.1:
    S_NOP 0, implicit %3.sub1
    S_NOP 0, implicit %0.sub1
    S_NOP 0, implicit undef %0.sub0
    S_ENDPGM
>>>>>>> origin/release/5.x

...

# Similar assert which happens when trying to rematerialize.
# https://bugs.llvm.org/show_bug.cgi?id=33884
---
# CHECK-LABEL: name: rematerialize_empty_interval_has_reference

# CHECK-NOT: MOV
<<<<<<< HEAD
# CHECK: undef %1.sub2:vreg_128 = V_MOV_B32_e32 1786773504, implicit $exec

# CHECK: bb.1:
# CHECK-NEXT: S_NOP 0, implicit %1.sub2
# CHECK-NEXT: S_NOP 0, implicit undef %4.sub0
# CHECK-NEXT: undef %2.sub2:vreg_128 = V_MOV_B32_e32 0, implicit $exec
# CHECK-NEXT: S_NOP 0, implicit %2.sub2
name: rematerialize_empty_interval_has_reference
tracksRegLiveness: true
machineFunctionInfo:
  scratchRSrcReg: $sgpr0_sgpr1_sgpr2_sgpr3
  scratchWaveOffsetReg: $sgpr4
  stackPtrOffsetReg: $sgpr32
=======
# CHECK: undef %3.sub2 = V_MOV_B32_e32 1786773504, implicit %exec

# CHECK: bb.1:
# CHECK-NEXT: S_NOP 0, implicit %3.sub2
# CHECK-NEXT: S_NOP 0, implicit undef %6.sub0
# CHECK-NEXT: undef %4.sub2 = V_MOV_B32_e32 0, implicit %exec
# CHECK-NEXT: S_NOP 0, implicit %4.sub2
name: rematerialize_empty_interval_has_reference
tracksRegLiveness: true
registers:
  - { id: 0, class: vreg_128, preferred-register: '' }
  - { id: 1, class: vgpr_32, preferred-register: '' }
  - { id: 2, class: vgpr_32, preferred-register: '' }
  - { id: 3, class: vreg_128, preferred-register: '' }
>>>>>>> origin/release/5.x
body:             |
  bb.0:
    successors: %bb.1

<<<<<<< HEAD
    undef %0.sub2:vreg_128 = V_MOV_B32_e32 0, implicit $exec
    undef %1.sub2:vreg_128 = V_MOV_B32_e32 1786773504, implicit $exec

  bb.1:
    S_NOP 0, implicit %1.sub2
=======
    undef %0.sub2 = V_MOV_B32_e32 0, implicit %exec
    undef %3.sub2 = V_MOV_B32_e32 1786773504, implicit %exec

  bb.1:
    S_NOP 0, implicit %3.sub2
>>>>>>> origin/release/5.x
    S_NOP 0, implicit undef %0.sub0
    S_NOP 0, implicit %0.sub2

...
